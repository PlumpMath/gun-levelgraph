{"version":3,"sources":["to-jsonld.js"],"names":["createToLdGraph","toLdGraph","toJsonLd","isRootNode","opts","visited","ids","length","defaultLogger","log","logging","args","logger","node","val","$val","_","id","soul","jsonld","context","schemaUrl","indexOf","push","fullPath","path","parse","field","fieldNode","fields","$fields","nodePaths","paths","concat","uniqFields","Set","result","json","JSON","stringify","spacer","chain","$toJsonLd"],"mappings":"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","file":"to-jsonld.js","sourcesContent":["import Gun from 'gun/gun'\n\nfunction isRootNode(opts) {\n  return !opts.visited || opts.visited.ids.length === 0\n}\n\nfunction defaultLogger(opts) {\n  return function log(...args) {\n    if (opts.logging) {\n      console.log('toLdGraph:', ...args)\n    }\n  }\n}\n\nlet log\n\nexport function createToLdGraph(opts) {\n  let logger = opts.logger || defaultLogger\n  log = logger(opts)\n  return {\n    toLdGraph,\n    toJsonLd\n  }\n}\n\nexport async function toLdGraph(node, opts = {}) {\n  log = opts.log || log\n\n  let val = await node.$val()\n  if (!val._) {\n    log('field', val)\n    return val\n  }\n\n  let id = Gun.node.soul(val)\n  log('node id:', id)\n\n  let jsonld = {\n    '@id': id\n  }\n\n  // if root node\n  if (isRootNode(opts)) {\n    let context = opts.schemaUrl || 'http://schema.org/'\n    log('root node:', context)\n    jsonld['@context'] = context\n  }\n\n  opts.visited = opts.visited || {\n    ids: []\n  }\n\n  if (opts.visited.ids.indexOf(id) >= 0) {\n    log('already visited:', jsonld)\n    return jsonld\n  }\n\n  opts.visited.ids.push(id)\n  let fullPath = (opts.path || '') + '/' + id\n  delete opts['paths']\n\n  async function parse(field) {\n    log('recurse', field)\n    let fieldNode = node.path(field)\n    opts.path = fullPath + '/' + field\n    return await toLdGraph(fieldNode, opts)\n  }\n\n  let fields = await node.$fields()\n  let nodePaths = opts.paths || []\n  nodePaths = nodePaths.concat(node._.paths || [])\n\n  if (nodePaths) {\n    fields = fields.concat(nodePaths)\n  }\n\n  let uniqFields = [...new Set(fields)]\n\n  log('parse fields', uniqFields)\n  for (let field of uniqFields) {\n    jsonld[field] = await parse(field)\n  }\n\n  log('jsonld:', jsonld)\n  return jsonld\n}\n\nexport async function toJsonLd(node, opts = {}) {\n  let result = await toLdGraph(node, opts = {})\n  return {\n    result,\n    json: JSON.stringify(result, null, opts.spacer || 2)\n  }\n}\n\nGun.chain.$toJsonLd = async function (opts) {\n  return await toJsonLd(this, opts)\n}"]}